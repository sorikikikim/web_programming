<!--
	1. 산술 연산
	+, -, *, /, % 
	나누기(/)의 결과는 실수

	2. 증감 연산
	++, --, 후위연산자(a++), 전위연산자(++a)

	3. 대입 연산
	오른쪽 식의 결과를 왼쪽에 있는 변수에 대입하는 것
	+= , -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=
	a+=b; 가 a=a+b; 보다 연산 속도가 빠름. 자기 자신에게 더하는 연산의 처리 과정이 일반적인 처리 과정보다 빠르기 때문.

	4. 비교 연산
	<, >, <=, >=, ==, != 
	true나 false 반환

	5. 논리 연산
	&&(AND), ||(OR), !(NOT)

	6. 조건 연산
	condition ? expT : expF
	condition이 true이면 조건식의 전체 결과는 expT의 계산 값이 되고, false이면 expF의 계산 값이 됨.

	7. 비트 연산
	비트끼리 AND, OR, XOR, NOT을 하는 비트 논리 연산과, 비트를 자리 이동시키는 비트 시프트 연산으로 나뉨.
		1) 비트 논리 연산
		a & b : AND 두 비트 모두 1이면 1, 아니면 0
		a | b : OR 두 비트 모두 0이면 0, 아니면 1
		a ^ b : XOR 두 비트가 다르면 1, 같으면 0
		~ a : NOT 1을 0으로, 0을 1로 변환

 		2) 비트 시프트 연산
		a << b : a의 비트들을 왼쪽으로 b번 이동. 최하위 비트의 빈자리는 0으로 채움. 한 비트 시프트마다 곱하기 2의 효과 발생. a 값은 변화 없음
		a >> b : a의 비트들을 오른쪽으로 b번 이동. 최상위 비트의 빈자리는 시프트 전 최상위 비트로 채움. 한 비트 시프트마다 나누기 2의 효과 발생. a 값은 변화 없음
		a >>> b : a의 비트들을 오른쪽으로 b번 이동. 최상위 비트의 빈자리는 0으로 채움. a 값은 변화 없음

	8. 문자열 연산
		1) 문자열 연결
		+, += 연산 시, 피연산자 중 하나라도 문자열이면 문자열 연결이 됨.
		"abc" + "de" = "abcde"
		"abc" + 23 = "abc23"
		23 + "35" = "2335"
		23 + 35 = 58
		23 + 35 + "abc" = 58 + "abc" = "58abc"
		"abc" + 23 + 35 = "abc2335"
		
		2) 문자열 비교
		비교 연산자(!=, ==, >, <, >=, <=)는 문자열 비교에 그대로 사용됨. 사전 순으로 판단.
		var name = "kitae";
		var res1 = (name == "kitae"); //res1 = true;
		var res2 = (name > "park"); //res2 = false; kitae가 park보다 사전에서 앞에 있음


	a & b 1 1 1
	1 0 01 0
	0 0 0
	console.log(3 || 0); 
	a | b 
	1 1 1
-->